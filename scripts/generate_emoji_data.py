#!/usr/bin/env python3
"""Generate compact Rust emoji metadata from the `emoji` and `emojis` packages."""

from __future__ import annotations

import argparse
import pathlib

import emoji
from emojis import db as emojis_db

CATEGORY_FLAG_ORDER: list[tuple[str, str]] = [
    ("Smileys & Emotion", "FLAG_SMILEYS_EMOTION"),
    ("Symbols", "FLAG_SYMBOLS"),
]
CATEGORY_TO_CONST: dict[str, str] = dict(CATEGORY_FLAG_ORDER)


def coalesce_ranges(entries: list[tuple[int, str]]) -> list[tuple[int, int, str]]:
    ranges: list[tuple[int, int, str]] = []
    current_start: int | None = None
    current_end: int | None = None
    current_flag: str | None = None

    for codepoint, flag in entries:
        if current_flag is None:
            current_start = current_end = codepoint
            current_flag = flag
            continue
        assert current_start is not None and current_end is not None
        if flag == current_flag and codepoint == current_end + 1:
            current_end = codepoint
            continue
        ranges.append((current_start, current_end, current_flag))
        current_start = current_end = codepoint
        current_flag = flag

    if current_flag is not None and current_start is not None and current_end is not None:
        ranges.append((current_start, current_end, current_flag))

    return ranges


def build_entries() -> list[tuple[int, str]]:
    entries: list[tuple[int, str]] = []
    for char, meta in emoji.EMOJI_DATA.items():  # type: ignore[attr-defined]
        if len(char) != 1:
            continue
        info = emojis_db.get_emoji_by_code(char)
        if info is None:
            info = emojis_db.get_emoji_by_code(f"{char}\ufe0f")
        category = info.category if info is not None else None
        if category is None:
            continue
        const = CATEGORY_TO_CONST.get(category)
        if const is None:
            continue
        entries.append((ord(char), const))
    entries.sort(key=lambda item: item[0])
    return entries


def emit(entries: list[tuple[int, str]]) -> str:
    flag_lines = [
        f"pub const {const_name}: u8 = 1 << {idx};"
        for idx, (_, const_name) in enumerate(CATEGORY_FLAG_ORDER)
    ]

    ranges = coalesce_ranges(entries)

    lines = [
        "// Auto-generated by scripts/generate_emoji_data.py; do not edit manually.",
        *flag_lines,
        "",
        "#[derive(Clone, Copy)]",
        "pub struct EmojiRange {",
        "    pub start: u32,",
        "    pub end: u32,",
        "    pub flags: u8,",
        "}",
        "",
        "pub static EMOJI_RANGES: &[EmojiRange] = &[",
    ]

    for start, end, flag in ranges:
        start_hex = f"0x{start:04x}"
        end_hex = f"0x{end:04x}"
        lines.append(
            f"    EmojiRange {{ start: {start_hex}_u32, end: {end_hex}_u32, flags: {flag} }},"
        )

    lines.append("];")
    lines.append("")
    return "\n".join(lines)


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--output",
        type=pathlib.Path,
        default=pathlib.Path("crates/fast-bunkai-rs/src/emoji_data.rs"),
        help="Path to the Rust source file to overwrite.",
    )
    args = parser.parse_args()

    entries = build_entries()
    content = emit(entries)
    args.output.write_text(content, encoding="utf-8")


if __name__ == "__main__":
    main()
