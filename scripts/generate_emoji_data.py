#!/usr/bin/env python3
"""Generate Rust emoji metadata from the `emoji` and `emojis` packages."""

from __future__ import annotations

import argparse
import pathlib

import emoji
import emojis


def build_entries() -> list[tuple[int, str | None]]:
    entries: list[tuple[int, str | None]] = []
    for char, meta in emoji.EMOJI_DATA.items():  # type: ignore[attr-defined]
        if len(char) != 1:
            continue
        info = emojis.db.get_emoji_by_code(char)
        if info is None:
            info = emojis.db.get_emoji_by_code(f"{char}\ufe0f")
        category = info.category if info is not None else None
        entries.append((ord(char), category))
    entries.sort(key=lambda item: item[0])
    return entries


def emit(entries: list[tuple[int, str | None]]) -> str:
    lines = [
        "// Auto-generated by scripts/generate_emoji_data.py; do not edit manually.",
        "pub static EMOJI_DATA: &[(u32, Option<&'static str>)] = &[",
    ]
    for codepoint, category in entries:
        hex_code = f"0x{codepoint:04x}"
        if category is None:
            cat_repr = "None"
        else:
            cat_repr = f'Some("{category}")'
        lines.append(f"    ({hex_code}, {cat_repr}),")
    lines.append("];")
    lines.append("")
    return "\n".join(lines)


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--output",
        type=pathlib.Path,
        default=pathlib.Path("src/emoji_data.rs"),
        help="Path to the Rust source file to overwrite.",
    )
    args = parser.parse_args()

    entries = build_entries()
    content = emit(entries)
    args.output.write_text(content, encoding="utf-8")


if __name__ == "__main__":
    main()
